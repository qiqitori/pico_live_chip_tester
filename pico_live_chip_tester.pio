.program ras_trigger
    ; pin 0: dout (from perspective of ram chip)
    ; pin 1: din (from perspective of ram chip)
    ; pin 2: ras
    ; pin 3: cas
    ; pin 4: we
    ; pin 5-12: address pins
.wrap_target
    wait 0 pin 2
    in pins, 13 ; read all pins
    push
    wait 1 pin 2
.wrap

.program cas_trigger
    ; pin 0: dout (from perspective of ram chip)
    ; pin 1: din (from perspective of ram chip)
    ; pin 2: ras
    ; pin 3: cas
    ; pin 4: we
    ; pin 5-12: address pins
.wrap_target
    wait 0 pin 3
    in pins, 13 ; read all pins
    wait 1 pin 3
    in pins, 1 ; read dout again
    push
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"
#include "pico_live_chip_tester.h"

#define CONSTANT_DIV 1.0
// #define PIO_CLK 200000000 // 200 MHz == 5 ns per clock cycle
// #define PIO_CLK 125000000 // 125 MHz == 8 ns per clock cycle, possibly good enough

static inline void ras_trigger_program_init(PIO pio, uint sm, uint offset, uint pin_base) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin_base, 13, false);
    pio_gpio_init(pio, pin_base);

    pio_sm_config c = ras_trigger_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin_base);
    // Shift existing values to the right when new value comes in
    sm_config_set_in_shift(&c, true, false, 0); // shift to right, no auto-push
#ifdef CONSTANT_DIV
    float div = CONSTANT_DIV;
#else
    float div = (float)clock_get_hz(clk_sys) / PIO_CLK;
#endif
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void cas_trigger_program_init(PIO pio, uint sm, uint offset, uint pin_base) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin_base, 13, false);
    pio_gpio_init(pio, pin_base);

    pio_sm_config c = cas_trigger_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin_base);
    // Shift existing values to the right when new value comes in
    sm_config_set_in_shift(&c, true, false, 0); // shift to right, no auto-push
#ifdef CONSTANT_DIV
    float div = CONSTANT_DIV;
#else
    float div = (float)clock_get_hz(clk_sys) / PIO_CLK;
#endif
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void get_bus_at_cas(PIO pio, uint sm1, uint sm2) {
    io_rw_32 *rxfifo_shift1 = (io_rw_32*)&(pio->rxf[sm1]);
    io_rw_32 *rxfifo_shift2 = (io_rw_32*)&(pio->rxf[sm2]);

    while (pio_sm_is_rx_fifo_empty(pio, sm2)) {
        g_waited++;
        tight_loop_contents();
    }
    /* Our RAS FIFO should be full by the time the CAS FIFO is full */
//     uint16_t rxfifo_contents1 = *rxfifo_shift1; // HACK See above
//     uint16_t rxfifo_contents2 = *rxfifo_shift2; // HACK See above
    g_state_at_ras = *rxfifo_shift1 >> 19;
    g_state_at_cas = *rxfifo_shift2 >> 18;
    g_ras_address = g_state_at_ras >> 5;
    g_cas_address = (g_state_at_cas >> 5) & 0xff; // filter out second dout
    g_is_read = (g_state_at_cas >> 4) & 1;
    g_is_write = !g_is_read;
    g_din = (g_state_at_cas>>1) & 1;
    g_dout = (g_state_at_cas>>13) & 1; // from the second reading
}

%}
